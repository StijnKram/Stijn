# -*- coding: utf-8 -*-
"""Optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HiVp-X5WQaSspIk97zWD6or3O9Vc9TDq
"""

import pandas as pd
import numpy as np
import plotly.express as px
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d

# Load the CSV file into a DataFrame with the correct delimiter and decimal handling
df = pd.read_csv('/content/drive/MyDrive/Master design poject/Data/vloeivelden_01-2023_05_2023_repowered.csv', delimiter=';', decimal='.', low_memory=False)

# Convert 'date_time' to datetime and check for errors in conversion
df['date_time'] = pd.to_datetime(df['date_time'], errors='coerce', format='%d-%m-%Y %H:%M')

# Set the 'date_time' column as the index for resampling
df.set_index('date_time', inplace=True)

# Resample the data to 15-minute intervals (you can adjust how you aggregate different columns)
df_resampled = df.resample('15T').mean()  # '15T' means 15-minute intervals

# Drop rows where essential columns ('feeder_01_kw' and 'feeder_02_kw') have missing values
df_clean = df_resampled.dropna(subset=['feeder_01_kw', 'feeder_02_kw']).copy()

# Convert the necessary columns to numeric values
df_clean['feeder_02_kw'] = pd.to_numeric(df_clean['feeder_02_kw'], errors='coerce')
df_clean['feeder_01_kw'] = pd.to_numeric(df_clean['feeder_01_kw'], errors='coerce')

# Set all negative 'feeder_02_kw' and 'feeder_01_kw' values to 0
df_clean['feeder_02_kw'] = df_clean['feeder_02_kw'].clip(lower=0)
df_clean['feeder_01_kw'] = df_clean['feeder_01_kw'].clip(lower=0)

# Define the date range where the scaling issue exists
outlier_period_start = '2024-02-01'
outlier_period_end = '2024-03-01'

# Adjust the 'feeder_01_kw' and 'feeder_02_kw' values during the scaling period
df_clean.loc[(df_clean.index >= outlier_period_start) &
             (df_clean.index <= outlier_period_end), 'feeder_01_kw' ] /= 1000
df_clean.loc[(df_clean.index >= outlier_period_start) &
             (df_clean.index <= outlier_period_end), 'feeder_02_kw' ] /= 1000

# Create a new column 'feeder_total_kw' which is the sum of 'feeder_01_kw' and 'feeder_02_kw'
df_clean['feeder_total_kw'] = df_clean['feeder_01_kw'] + df_clean['feeder_02_kw']

# Ensure all columns used in the plot are of the same length
df_clean = df_clean.dropna(subset=['feeder_total_kw'])

# Filter the data to only include the first 5 days (use .copy() to avoid SettingWithCopyWarning)
first_5_days = df_clean.loc[df_clean.index <= df_clean.index[0] + pd.Timedelta(days=2)].copy()
first_5_days = pd.DataFrame(first_5_days, columns=['feeder_total_kw'])

# Now the first 5 days of data will be used for further processing
plt.figure(figsize=(12, 6))
plt.plot(first_5_days.index, first_5_days['feeder_total_kw'], label='Feeder Total Power')

# Load the data, ensuring that commas are correctly interpreted as decimal points
df = pd.read_csv('/content/drive/MyDrive/Master design poject/Data/Efficiency.csv', decimal=',')

# Select and clean relevant columns
efficiency_data = df.iloc[0:5, 0:2]  # Adjust row selection as needed

# Rename columns if needed, or confirm they match the following:
efficiency_data.columns = ['load (%)', 'Efficiency BoL (kWh/kg)']

# Convert columns to numeric, forcing errors to NaN, and drop rows with NaN values
efficiency_data['load (%)'] = pd.to_numeric(efficiency_data['load (%)'], errors='coerce')
efficiency_data['Efficiency BoL (kWh/kg)'] = pd.to_numeric(efficiency_data['Efficiency BoL (kWh/kg)'], errors='coerce')
efficiency_data_clean = efficiency_data.dropna()  # Drop any rows with NaN values

# Set up interpolation function
load_values = efficiency_data_clean['load (%)'].values
efficiency_values = efficiency_data_clean['Efficiency BoL (kWh/kg)'].values
efficiency_interpolation = interp1d(load_values, efficiency_values, kind='linear', fill_value="extrapolate")

# Define efficiency function Eff(P)
def Eff(P):
    load_percentage = min((P / P_max) * 100, 100)
    return efficiency_interpolation(load_percentage)
# Define hydrogen production function H(P)
def H_func(P):
    return P / (4 * Eff(P))



from scipy.optimize import minimize
import numpy as np
import plotly.express as px

# Constants
min_operating_power = 1500  # Minimal operating power of PEM (1.5 MW in kW)
max_power = 5000  # Max power in kW
max_ramp = 75000   # Max change is 5000 kW per minute
a = 1          # Weight for hydrogen production penalty
b = 5        # Weight for fluctuation penalty
c = 0.1        # Weight for hydrogen production tracking error

N = 3            # Control horizon
H_desired = 22     # Target hydrogen production per time step [kg/15 min]

# Example feeder_total_kw array (replace this with actual data)
feeder_total_kw = first_5_days['feeder_total_kw'].values
J= len(feeder_total_kw) #Prediction horizon

# Efficiency function based on power
def Eff(P):
    # Calculate load percentage as an array, capped at 100%
    load_percentage = np.minimum((P / max_power) * 100, 100)  # Element-wise minimum at 100%
    return efficiency_interpolation(load_percentage)  # Assume efficiency_interpolation can handle arrays

# Hydrogen production function
def H(P):
    return P / (4 * Eff(P))  # Hydrogen production in [kg] per 15 minutes

# Storage for optimized values
pem_optimized = np.zeros_like(feeder_total_kw)

# Define the objective function with hydrogen production tracking
def cost_function(pem_power, feeder_total_kw):
    tracking_error = np.sum((feeder_total_kw[:len(pem_power)] - pem_power)**2)
    fluctuation_penalty = np.sum((np.diff(pem_power))**2)  # Penalize changes between successive values
    hydrogen_production_error = np.sum((H_desired - H(pem_power))**2)  # Penalize deviations from H_desired
    return a * tracking_error + b * fluctuation_penalty + c * hydrogen_production_error

# Define the ramp rate constraints
def ramp_constraints(pem_power):
    return max_ramp - np.abs(np.diff(pem_power))
# Define constraint to ensure pem_power <= P_solar
def power_upper_bound_constraint(pem_power, feeder_horizon):
    return feeder_horizon - pem_power

# MPC Loop over time steps
for t in range(J - N):
    # Define the horizon's feeder data
    feeder_horizon = feeder_total_kw[t:t + N]

    # Initial guess for optimization within the prediction horizon
    pem_initial_guess = np.clip(feeder_horizon, min_operating_power, max_power)

    # Define bounds within the prediction horizon
    bounds = [(0, max_power) if feeder_horizon[i] >= min_operating_power else (0, 0)
              for i in range(N)]

    # Define constraints
    constraints = [
         {'type': 'ineq', 'fun': ramp_constraints},
         {'type': 'ineq', 'fun': power_upper_bound_constraint, 'args': (feeder_horizon,)}]

    # Perform optimization for the current prediction horizon
    result = minimize(cost_function, pem_initial_guess, args=(feeder_horizon,),
                      bounds=bounds, constraints=constraints, method='SLSQP')

    # Extract the optimized power value for the first step and apply it
    if result.success:
        pem_optimized[t] = result.x[0]
    else:
        print(f"Optimization failed at step {t}")
        pem_optimized[t] = pem_initial_guess[0]  # Use initial guess if optimization fails

# Enforce that PEM is zero when feeder_total_kw is below the minimal operating power
pem_optimized[feeder_total_kw < min_operating_power] = 0

# Add the optimized PEM values to the DataFrame using .loc to avoid SettingWithCopyWarning
first_5_days.loc[:, 'PEM_optimized'] = pem_optimized

# Plot the results
fig = px.line(first_5_days, x=first_5_days.index, y=['feeder_total_kw', 'PEM_optimized'],
              labels={'value': 'Power (kW)', 'variable': 'Feeder Total vs PEM Optimized'},
              title='Feeder Total Power vs Optimized PEM Power (First 5 Days)')

fig.show()



from scipy.optimize import minimize
import numpy as np
import plotly.graph_objects as go

# Constants
min_operating_power = 1500  # Minimal operating power of PEM (1.5 MW in kW)
max_power = 5000  # Max power in kW
max_ramp = 75000  # Max change is 75000 kW per minute
a = 0.000000000000000  # Weight for hydrogen production penalty
b = 0 # Weight for fluctuation penalty
c = 0.00000000005  # Weight for hydrogen production tracking error
J = len(feeder_total_kw)  # Prediction horizon
N = 3  # Control horizon
H_desired = 22  # Target hydrogen production per time step [kg/15 min]

# Example feeder_total_kw array (replace this with actual data)
feeder_total_kw = first_5_days['feeder_total_kw'].values

# Efficiency function based on power
def Eff(P):
    load_percentage = np.minimum((P / max_power) * 100, 100)  # Element-wise minimum at 100%
    return efficiency_interpolation(load_percentage)  # Assume efficiency_interpolation can handle arrays

# Hydrogen production function
def H(P):
    return P / (4 * Eff(P))  # Hydrogen production in [kg] per 15 minutes

# Storage for optimized values and cost values
pem_optimized = np.zeros_like(feeder_total_kw)
cost_values = []  # List to store the cost at each time step

# Define the updated objective function to include predicted values
def cost_function(pem_power, feeder_horizon):
    total_cost = 0
    for k in range(len(pem_power)):
        # Calculate tracking error, fluctuation penalty, and hydrogen production error for each step
        tracking_error = (feeder_horizon[k] - pem_power[k])**2  # Use k only
        if k > 0:  # Fluctuation penalty for changes between successive values
            fluctuation_penalty = (pem_power[k] - pem_power[k - 1])**2  # Correct the indexing
        else:
            fluctuation_penalty = 0
        hydrogen_production_error = (H_desired - H(pem_power[k]))**2  # Use k only

        # Accumulate the total cost with weights
        total_cost += a * tracking_error + b * fluctuation_penalty + c * hydrogen_production_error

    return total_cost

# Define the ramp rate constraints
def ramp_constraints(pem_power):
    return max_ramp - np.abs(np.diff(pem_power))

# Define constraint to ensure pem_power <= P_solar
def power_upper_bound_constraint(pem_power, feeder_horizon):
    return feeder_horizon - pem_power

# Outer loop over k
for t in range(J - N - 1):  # Adjusted to ensure the loop is one step behind
    # Inner optimization loop over t
    k = t + 1  # Ensure k is one step ahead of t
    if t >= J - N:  # Break if t exceeds the bounds
        break

    # Define the horizon's feeder data
    feeder_horizon = feeder_total_kw[t:t + N]

    # Initial guess for optimization within the prediction horizon
    pem_initial_guess = np.clip(feeder_horizon, min_operating_power, max_power)

    # Define bounds within the prediction horizon
    bounds = [(0, max_power) if feeder_horizon[i] >= min_operating_power else (0, 0)
              for i in range(N)]

    # Define constraints
    constraints = [
        {'type': 'ineq', 'fun': ramp_constraints},
        {'type': 'ineq', 'fun': power_upper_bound_constraint, 'args': (feeder_horizon,)}
    ]

    # Perform optimization for the current prediction horizon
    result = minimize(cost_function, pem_initial_guess, args=(feeder_horizon,),
                      bounds=bounds, constraints=constraints, method='SLSQP')

    # Extract the optimized power value for the first step and apply it
    if result.success:
        pem_optimized[t] = result.x[0]
        # Calculate and store the cost using the optimized pem_power
        cost = cost_function(result.x, feeder_horizon)
        cost_values.append(cost)
    else:
        print(f"Optimization failed at step {t}")
        pem_optimized[t] = pem_initial_guess[0]  # Use initial guess if optimization fails
        cost_values.append(None)  # Append None if optimization fails

# Enforce that PEM is zero when feeder_total_kw is below the minimal operating power
pem_optimized[feeder_total_kw < min_operating_power] = 0

# Normalize the cost values with respect to the maximum power value
cost_values_normalized = np.array(cost_values) / np.max(feeder_total_kw)

# Add the optimized PEM values to the DataFrame using .loc to avoid SettingWithCopyWarning
first_5_days.loc[:, 'PEM_optimized'] = pem_optimized

# Create a combined plot using plotly.graph_objects
fig = go.Figure()

# Add feeder_total_kw and PEM_optimized as line plots
fig.add_trace(go.Scatter(x=first_5_days.index, y=first_5_days['feeder_total_kw'],
                         mode='lines', name='Feeder Total (kW)'))
fig.add_trace(go.Scatter(x=first_5_days.index, y=first_5_days['PEM_optimized'],
                         mode='lines', name='PEM Optimized (kW)'))

# Add normalized cost function as a secondary y-axis
fig.add_trace(go.Scatter(x=first_5_days.index[:len(cost_values_normalized)],
                         y=cost_values_normalized, mode='lines',
                         name='Normalized Cost Function', yaxis='y2'))

# Update layout for dual y-axes and add parameters a, b, c to the title
fig.update_layout(
    title=f'Sun profile, optimized power input PEM and the cost function (a={a}, b={b}, c={c})',
    xaxis_title='Time',
    yaxis_title='Power (kW)',
    yaxis2=dict(
        title='Normalized Cost',
        overlaying='y',
        side='right'
    ),
    legend=dict(
        x=1.05,  # Position legend to the right side
        y=1,
        xanchor='left'
    )
)

fig.show()